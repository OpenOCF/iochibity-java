This layer is the interface between the app and the engine. It
provides services to apps, and "coservices" to underlying
layers.

The key services are "exhibit" and "coexhibit". That's all we need; no
need to reify client/server roles as classes.

Why not put both in one class? Because client apps only need coexhibit
and server apps only need exhibit. No need to include both except for
client-server apps.

Registration: server apps need to register resource SPs; client apps
need to register coresource SPs (callbacks).

Both need to register core resources (platform, device).

On the client side, the engine needs to database inbound
responses. Client apps can direct the engine to retain messages, and
can query the engine to inspect retained messages. To support this we
need a "client services" API. Which is really a messaging db
management services API: CoResourceDBM? Or MessagingDBM?

Messaging: instead of messages we think in terms of behaviors. Two
kinds, exhibitable stimulii and observable responses:

    Behavior (Record)
        Exhibitable
	    OutboundStimulus - co-exhibited by client (send request msg)
	    OutboundResponse - exhibited by server (send response msg)
        Observable
	    InboundStimulus - observed by server (recv request msg)
	    InboundResponse - co-observed by client (recv response msg)

E.g., an inbound response is an observable behavior record - a record
of the server's exhibited response behavior.

BUT: messages have payloads. So e.g. an InboundResponse _contains_ a
behavior record as payload.

Clients store observed behavior records (response messages). Servers
react to observed behavior records (request messages) but do not
retain them (although they could, for logging/traceability).
